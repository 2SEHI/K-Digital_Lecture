# Service구현
- 클라이언트가 사용할 수 있는 제품을 만드는 작업을 서비스 구현이라고 하는데 애플리케이션 구현이라고도 합니다.



## 1.Service의 종류



### 1) 디바이스에 설치해서 동작하는 경우
- 디바이스의 모든 기능을 활용하는 것이 가능
- 실행속도가 빠름
- 업데이트가 느림
- 설치한 디바이스에서만 동작하여 데이터 공유(클라우드)를 이용해서 많이 해결



### 2) 설치할 필요없이 동작하는 경우
- Web Application 들이 보통 설치를 하지 않습니다.
- Web Browser를 통해서 서비스를 사용하므로 Web Browser를 설치를 해야하는데 지금의 운영체제는 대부분 Web Browser를 내장하고 있기 때문에 설치를 할 필요가 없다고 합니다.



## 2.일반적인 구조
```
 입력 ---> 처리 ---> 출력
          (저장)
```
- 입출력하는 곳과 처리하는 곳이 다르면 클라이언트 - 서버 시스템이라고 합니다.
- 입출력하는 곳은 클라이언트, 처리하는 곳을 서버라고 합니다
- Edge Computing : 최근에는 입출력하는 곳에서 처리도 하고 서버는 단지 데이터를 저장하는 용도로만 사용하기도 하는데 보안때문에 이렇게 구현합니다.



## 3.네트워크 방식에 따른 분류





### 1) Low Level 통신

- 속도가 빠름
- 구현이 어려움.
- 저수준의 프로토콜
- TCP/UDP 소켓 프로그래밍: 소켓프로그래밍이라고 하면 통상적으로 Low Level이라고 합니다.



### 2) Hight Level 통신
- 속도는 일반적으로 Low Level통신보다 느리지만 구현이 쉽습니다.
- 웹 서버 프로그래밍



## 4.입출력 방식 - View
- 응용 프로그램의 형태로 구현하고자 하는 경우에는 콘솔로 **입출력(Command Line Interface)**할 것인지 **윈도우로 입출력(Graphic User Interface)**할 것인지를 결정해야 합니다. 그밖에도 음성 등을 활용한 방식도 있습니다.



### 1) 콘솔 입출력 
- 프로그래밍 언어의 입출력을 학습하면 됩니다.



### 2) 윈도우 입출력(GUI)
- PyQt나 다른 언어의 GUI(VC++, VC#, Java의 Swing이나 F/X등)과 같은 모듈을 학습해야 합니다. 
- Web Application의 형태로 구현하는 경우에는 HTML, CSS, JavaScript 를 학습해야 합니다. 
    - HTML : 문서의 구조 생성
    - CSS : 문서에 디자인을 설정
    - JavaScript : 문서에 동적인 기능을 수행
    - TypeScript : JavaScript에 객체 지향 문법을 추가한 언어로 현재의 자바스크립트 표준은 ES6 + TypeScript를 의미하는 경우가 많습니다. JavaScript를 공부한다면 TypeScript까지 공부하는 것이 좋습니다.
    - Node.js : JavaScript를 이용해서 웹 서버를 구현할 수 있는 라이브러리로 스타트업에서 많이 사용합니다. 데이터 베이스에 대한 기본 개념을 가지고 학습해야 합니다. 이와 유사한 역할을 수행하는 것이 Python의 Flask나 Django입니다.
    - react.js, vue.js, angular.js : 서버의 데이터를 가져와서 출력하기 위한 자바스크립트 라이브러리로 ajax에 대한 선수 지식과  xml, json에 대한 개념이 있어야 합니다.
    - jquery : cross browsing과 동적인 css적용을 편리하게 하기 위한 자바스크립트 라이브러리이고 다양한 플러그인을 가지고 있습니다.
        - cross browsing : 모든 브라우저에서 동일하게 콘텐츠를 사용할 수 있도록 하는 것
    - bootstrap.js : 반응형 웹 페이지 구현을 쉽게 하기 위한 자바스크립트 라이브러리
        - 반응형 웹 페이지 : 브라우저 크기에 상관없이 동일하게 콘텐츠를 사용할 수 있도록 하는 것
    - eletron : 웹 OS기반의 응용 프로그램을 만드는 자바스크립트 라이브러리



### => Node.js를 제외한 나머지는 javascript로 가능



## 5.서버 구현



### 1) 처리 결과를 클라이언트에 화면으로 제공하는 방식



### 2) REST API방식 
- 처리 결과 자체를 클라이언트에게 전달하는 방식
- 클라이언트 측에서 ajax, json 파싱같은 것을 할 수 있어야 합니다.
- 클라이언트에서 그래프 같은 것을 출력하고자 할 때 고민을 해봐야 합니다
- 서버가 그래프까지 그려서 클라이언트에게 전달하게 되면서 서버의 부하가 커지고 느려질 수 있는데 클라이언트에서 데이터를 받아서 직접 그래프를 그리면 서버의 부하를 줄일 수 있고 출력 속도도 더 빨라질 수 있습니다.



## 6.저장소 구현
- 로컬에 저장하는 방법과 서버에 저장하는 방법으로 나눌 수 있습니다.



### 1) 로컬 저장 방법
- 로컬에 저장하는 방법으로는 일반 파일 시스템 또는 SQLite같은 경량의 관계형 데이터 베이스 또는 웹 브라우저의 저장소(Cookie, Web SQL, Indexed DB, Storage 등)를 사용할 수 있습니다.
- 이방법은 프로그램을 삭제하거나 브라우저를 삭제하면 데이터가 모두 소멸됩니다.
- 다른 컴퓨터와 공유할 수 없습니다.



### 2) 서버 저장 방법
- 서버에 저장하면 클라이언트 프로그램이 삭제되더라도 데이터를 유지할 수 있고 다른 컴퓨터와 공유할 수 있습니다.



### 3) 저장소의 종류
- 일반 Flat파일 : 텍스트 파일(txt, csv 등), 음성 파일, 그림 파일 등으로 저장 바로 재생하거나 내용이 잘 변경되지 않는 경우에 사용. 은성이나 그림은 빨리 재생시키기 위함.
- 데이터베이스 활용 : 관리가 편리하지만 비용이 많이 듭니다. RDBMS와 NoSQL으로 나누어짐.
    - RDBMS : 테이블 기반, Class기반
    - NoSQL : 데이터의 모임 기반, Map이나 dict기반
- 분산 파일 시스템 활용 : 빠르게 생성되는 많은 양의 데이털르 관리하는 용도로 사용, Hadoop이 대표적인데 Hadoop에 Echo System(Spark이 대표적)을 부가해서 데이터 분석이나 가곡 작업을 편리하게 해줍니다.



## 7.개발과정



### 1) 요구사항 분석 
- 무엇을 어떻게 만들 것이냐 하는 것. 입출력을 결정. 



### 2) 설계
- 모델링. 어떻게 구현할 것인가?
- 어떻게 저장하고 처리할 것인지?



### 3) 구현



### 4) 시험 - 테스트



### 5) 배포 / 이행
- 배포 : 응용프로그램을 만든 경우 클라이언트들이 사용할 수 있도록 하는 것
- 이행 : 개발 환경해서 운용환경으로 이전하는 것. 예전 큰 기업은 운영환경을 자체적으로 운영했는데 최근에는 클라우드 환경(AWS, GCP, AZURE 등)을 사용하는 경우가 많습니다.



### 6) 유지보수



---

# SI 와 SM



## 1.SI(System Integrator) : 시스템 통합

- 직군으로 얘기할 때 기업에서 전산 시스템을 도입해야 하는데 직접 구축하는 것이 어려운 경우 외부 업체에 의뢰해서 시스템을 구축하는 것
- SI업무를 담당하는 대표적인 회사가  삼성 SDS, LG CNS, SK C&C, CJ 이런 회사들은 자체적인 개발을 하는 경우는 프레임워크 개발 정도만 하고 나머지는 다른 회사의 시스템을 구축하는 일을 합니다.
- 우리나라에서는 대기업은 PM의 역할만하고 나머지는 다시 하청의 형태로 일을 합니다.
- PM이 개발 환경이나 운영환경 등을 설계하고 데이터베이스 설계도 하는데 데이터베이스 설계를 모델링이라하고 이부분을 대부분 컨설팅 업체에 의뢰를 합니다.



## 2.SM(System Mangament)

- SI에서 개발한 시스템을 운영하고 유지보수 하는 작업
- 예를 들면 IBK  System, 신한 데이터 시스템 등의 회사가 대표적입니다. 



---

# 데이터 베이스 모델링



## 1.RDBMS(Relation Data Base Management System)
- 관계형 데이터베이스 시스템
- 데이터베이스를 테이블의 집합으로 표현하는 데이터베이스 관리 시스템



### 1) 종류
- 상용화된 시스템 : Oracle, MySQL, IBM DB2, MS-SQL, HANA DB, Tibero, TeraData Database  등의 제품이 있습니다. 대기업은 Oracle, HANA DB, 중견기업은 MySQL, 공공기관은 Tibero
- 오픈 소스 : MySQL의 fork인 Maria DB, Postgre SQL, SQLite(로컬에서만 사용 가능하고 웹브라우저나 파이썬에 내장 - 임베디드 시스템에서 주로 이용)



### 2) 용어
- Relation : 테이블,  Schema : 구조 - 클래스
- Attribute : 속성. 테이블에서 열
- Tuple : Record나 Row라고도 함.  테이블에서 행
- Domain : 속성이 가질 수 있는 값의 집합
- Cardinality : 기수. 행의 개수
- Degree : 차수. 열의 개수



### 3) Key (식별자)
- 데이터를 한 개로 구별할 수 있는 속성이나 속성의 집합
- Candidate Key : 후보키. 속성의 개수가 최소인 키
- Primary Key : 기본키, 주식별자. 후보키 중에서 선정한 키 하나만 선정해야 하고 테이블 내에서 유일한 식별자로 사용. 이것을 설계 단계에서 못만들 때 일련 번호를 사용
- Alternate Key : Primary Key 가 아닌 Candidate Key. 예를 들어, 회원가입시 등록하는 별명이  Alternate Key입니다.
- Foreign Key : 외래키, 참조키. 다른 테이블의 데이터를 참조할 수 있도록 설정한 키로 다른 테이블에서는 Primary key(실제 데이터베이스에서는 unique속성만 만족하면 됩니다)이어야 합니다.



### 4) Constraint(제약 조건)
- Entity Integrity: 개체 무결성. Primary Key는 null이거나 중복될 수 없다
- Referential Integrity : 참조 무결성. Foreign Key는 null일 수 있고 다른 테이블에 없는 값을 가질 수는 없다.



## 2.No SQL
- 데이터의 집합을 테이블을 이용하지 않고 구현하는 데이터베이스



### 1) 종류
- Mongo DB나 google의 firebase가 대표적



## 3.데이터베이스의 설계
- 일반적으로 데이터베이스 모델링이 개발의 첫단계이고 이 모델링한 데이터를 기반으로 시스템이 구축됩니다.
- 이 부분이 잘못되면 다른 모든 부분에 영향을 주게 됩니다.



### 1) 생명 주기
```
기획 -> 분석 -> 설계 -> 구현 -> 테스트 -> 수정 및 유지보수
```



### 2) 설계단계
- 엔티티(테이블) 정의 -> 속성 정의 -> 식별자 선정 -> 관계 설정 -> 정규화 -> 역정규화(또는 반정규화)



## 4.모델링의 관점
- 프로세스 모델링 : 작업관점
- 데이터 모델링 : 데이터 관점
- 상관관계 모델링 : 둘사이의 관계



## 5.모델링의 특징
모델링을 잘하게되면 업무를 분석하고 설계하는데 이용하고 변경과 관리를 잘 할 수 있게 됩니다.
- 추상화 : 그림을 그리자
- 단순화
- 명확화


ER다이어그램은 대화의 수단이므로 읽을 수 있어야 합니다.



## 6.모델링의 3단계 진행



### 1) 개념적 모델링
- 고객의 요구사항을 도식화. 그림 그릭



### 2) 논리적 모델링
- 실제 구현을 하기 위한 단계. 이게 보통 설게



### 3) 물리적 무델링
- 실제 구현을 할 수 있도록 여러가지 다른 문제를 고려



## 7.스키마



### 1) External Schema(외부 스키마)
- 고객이 바라보는 관점의 데이터베이스



### 2) Conceptual Schema(개념 스키마)
- 전체 데이터베이스



### 3) Internal Schema( 내부 스키마)
- 실제 저장되는 물리적인 개념의 스키마
- create ~ 하는 것



## 8.ER Diagram
ER Diagram 의 정보 공학 표기법이 많이 쓰입니다. 
- 사각형 : Relaction(테이블)
- 원 : 속성
- 마름모 : 관계
- 선 : 연결
- 속성 중에서 기본키이면 밑줄을 긋거나 색을 채웁니다.



## 9.데이터 모델링 고려사항
- 좋은 데이터 모델은 업무에서 필요한 것이 다 정의되어 있는 것입니다. 고객에게 더 필요로 하는게 없는지 계속해서 물어봐야 합니다.



### 1) 데이터 모델의 독립성



### 2) 고객 요구사항의 표현



### Entity와 Instance
- Entity가 실제 구현되면 Instance
- Entity는 Instance의 집합입니다.



### Entity의 명명
- 웬만하면 실생활에서 상용하는 단어를 그대로 쓰고 약어를 쓰지 않는 것이 좋습니다



### 속성
- 클래스 변수의 개념
- 분리할 수 있다고 전부 속성은 아닙니다.

- 기본 속성 : 업무로부터 추출한 모든 속성
- 설계속성 : 일련번호같은 것
- 파생속성 : 속성에 의해 만들어 진것. 도,시,군으로 만들어진 주소



### 도메인
- 속성이 가질 수 있는 값의 범위
-  주소는 20자리 문자열 



### 관계
- 테이블은 반드시 관계를 가져야 합니다



## 10.외래키생성 방법
### 1) 1:1관계
- 각 테이블의 기본키를 다른 테이블의 외래키로 설정합니다.




### 2) 1:N관계
- 1 쪽의 기본키를 N쪽의 외래키로 추가
- 회원 테이블의 기본키가 아이디이고 게시판 테이블의 기본키가 게시물 번호인 경우 회원은 여러 개의 게시글을 작성할 수 있고 1개의 게시글은 1명의 회원만 작성할 수 있다면 회원 테이블의 기본키인 아이디를 게시물 테이블에 외래키로 추가해야 합니다.




### 3) N:M관계
- 양쪽 테이블의 기본키를 외래키로 갖는 별도의 테이블을 생성해야 합니다
- 고객 테이블이 있고 상품 테이블이 있는 경우 1명의 고객이 여러 개의 상품을 구입할 수 있고 1가지 상품을 여러 고객이 구매할 수 있다면 고객 테이블의 기본키와 상품 테이블의 기본키를 외래키로 갖는 주문 테이블을 별도로 생성합니다.



## 11.정규화




### 1) Anomaly(이상 현상)
- 삽입, 삭제, 갱신작업을 하고자 할 때 문제가 발생하는 현상입니다
- 이상이 발생하는 이유는 데이터의 중복때문입니다.



수강신청 관련 테이블을 만든다고 할 때 학번, 이름, 전화번호, 수강과목코드, 과목이름, 담당 교수로 구성하고자 합니다.



다른 테이블과 구분하기 위해 기본키를 만들어야 하는데 학번 또는 수강과목코드만 가지고 기본키를 만들기에 학생당 여러개의 과목을 신청하고 과목도 여러학생이 신청할 수 있기 때문에 기본키를 (학번 + 수강과목 코드)로 구성합니다.



#### 삽입이상

-  데이터를 삽입하고자 하는데 데이터를 삽입할 수 없는 현상.
  - 수강신청 테이블에 다음 학기를 위해서 수강과목을 추가하고자 하는 경우 -> 학생의 학번이 없으므로 삽입 이상 발생
  - 수강신청을 하지 않은 학생정보를 추가하고자 하는 경우 -> 수강 과목 코드가 없으므로 삽입 이상 발생

#### 갱신이상 

- 수정하고자 하는 데이터는 1개인데 여러번 수정해야 해서 일관성에 문제가 발생할 수 있는 현상
  - 학생 1명이 여러 과목을 수강할 수 있는데 학생의 전화번호를 수정하면 1개의 행만 수정되는 것이 아니라 여러 개의 데이터가 수정되어야 할 수도 있습니다.

  

#### 삭제 이상

- 데이터를 삭제할 때 필요한 정보도 같이 삭제되는 현상
  - 1명의 학생만 수강하는 과목이 존재하는 경우 이 학생의 데이터를 삭제하면 학생에 대한 정보와 수강 과목에 대한 정보가 함께 사라집니다.

  - 중복된 코드를 여러번 쓰는 것을 스파게티 소스라고 하는데 소스를 수정하고자 할 때 중복된 곳을 전부 수정해야 합니다. 그래서 함수와 클래스를 사용하는 것입니다.




### 2) Function Dependency(함수적 종속)
- 어느 하나의 속성이 다른 속성의 값을 1개로 결정지을 때 이를 함수적 종속이라고 합니다.
- 주민등록번호를 알면 이름을 1개로 결정할 수 있습니다.
- 주민등록번호가 이름을 함수적으로 종속했다고 하고 주민등록번호 -> 이름의 형태로 표현합니다.



#### 완전 함수 종속
- 기본키가 2개 이상의 속성으로 만들어진 경우 2개 이상의 속성 모두를 알아야만 다른 속성을 1개로 결정할 수 있는 경우



#### 부분 함수 종속
- 기본키가 2개 이상의 속성으로 만들어진 경우 기본키 중 일부분만 알아도 다른 속성을 1개로 결정할 수 있는 경우



#### 이행적 함수 종속
- A 가 B를 함수적으로 종속하고 B 가 C를 함수적으로 종속한다면 A 가 C를 함수적으로 종속합니다. 이 경우를 이행적 함수 종속이라고 합니다.



### 3) Normalization(정규화)
- 테이블을 분할해서 중복을 제거해서 이상 현상을 제거하는 것을 뜻합니다
- 정규화는 1정규화 부터 5정규화 까지 6가지인데 일반적으로 3정규형 이나 BCNF 정도까지만 수행합니다.
- 너무 많은 정규화를 수행하면 테이블이 너무 많이 분해되서 select 할 때 join 작업이 빈번히 발생해서 속도가 느려집니다.

#### 1정규형(1NF)
- 테이블에 존재하는 모든 속성 값은 더 이상 분해되지 않는 원자값이어야 합니다.


#### 제2정규형(2NF)
- 1NF를 만족하고 모든 속성이 기본키에 대해서 완전 함수 종속이어야 합니다.
- 부분 함수적 종속을 제거 - 기본키가 하나의 속성으로 만들어져 있으면 2정규형까지는 만족한 것임. 부분 함수적 종속이 있다면 별도의 테이블로 분해합니다.

#### <수강신청 관련 테이블>
- 속성 : 학번, 이름, 전화번호, 수강과목코드, 과목이름, 담당교수로 구성
- 기본키 : (학번, 수강과목코드) - 기본키는 2개 이상의 속성으로도 구성 가능

#### 위의수강신청 관련 테이블을 2정규화를 수행
- 이름과 전화번호는 학번만 알아도 되므로 학번, 이름, 전화번호를 갖는 테이블로 분해하고 과목이름과 담당교수도 수강과목코드만 알명 알 수 있으므로 수강과목 코드, 과목이름, 담당교수를 별도의 테이블로 만들고 수강과목코드만을 갖는 테이블로 생성


#### 3정규형(3NF)
- 2NF를 만족하고 이행적 함수 종속이 존재하지 않아야 합니다.
- 이행적 함수 종속이 있다면 별도의 테이블로 분해합니다

#### BCNF(강한 3정규형)
- 3NF를 만족하고 모든 결정자가 후보기이어야 합니다. 결정자는 함수적 종속을 표현할 때 왼쪽 편에 있는 속성입니다.



#### 4NF 
- 3NF를 만족하고 MVD(Multi Valued Dependency)가 제거되어야 합니다
- 하나의 속성이 다른 속성의 값 여러 개를 결정하면 다가 종속이라고 합니다.



#### 5NF
- 4NF를 만족하고 JD(Join Dependency)가 제거되어야 합니다.

### 정규화의 문제점
- 테이블이 너무 많이 분해되서  select 를 할 때 JOIN연산이 많이 발생해서 검생 성능이 떨어집니다.
- 그래서 테이블을 합치는 역 정규화 등을 수행합니다.

## 12.반정규화(Denormalization)
- 역정규화와 반정규화는 약간 다릅니다
- 원래 반정규화는 데이터베이스 검생 성능을 높이기 위한 모든 작업을 뜻합니다.

- 자주 사용하는 데이터끼리는 묶어주는 것이 좋습니다.
- 자주 사용하는 데이터와 자주 사용하지 않은 데이터가 같이 존재한다면 분해해야 합니다.


고객 테이블을 생성해서 데이터를 저장한다고 할 때
- 자주 로그인하는 고객 데이터는 100개, 자주 사용하지 않는 고객 데이터는 10만개인 경우 현재 테이블에는 100100개의 데이터가 존재합니다.
- 로그인을 처리하기 위해서 100100개의 데이터에서 찾는 것보다는 2개의 데이터를 분해해서 별도의 테이블에 저장하고 있다면 자주 로그인하는 데이터를 저장하고 있는 테이블에서 찾고 없으면 자주 로그인하지 않는 데이터를 저장하는 테이블에서 찾는 방식이 있을 수 있습니다.



## 13.Data Warehouse

- 데이터 베이스에서 필요한 데이터만 추출하는 것을 의미합니다. 
- 이때 데이터는 특정 주제나 부서별로 존재하는 데이터를 의미합니다.




## 14.Data Mining
- 이전의 방식들은 프로그램이 데이터베이스를 이용하는 형태였습니다. 
- 최근의 Data Mining은 대용량의 데이터에서 필요한 지식을 얻고자 하는 과정을 말합니다.
